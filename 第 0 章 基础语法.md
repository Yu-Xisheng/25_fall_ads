- # 第 0 章

  # Python 语法 × 算法工具箱

  本章目标只有一个：**把 Python 语法讲成“算法语言”而不是“脚本语言”**。

  你后面学到的所有算法（DP / 搜索 / 贪心 / 图），本质上都只是：

  > 用 Python 语法去**表达状态、推进状态、做决策**。

  ------

  ## 0.1 Python 在算法中的三种角色

  你后面写的任何算法代码，都可以拆成这三类：

  | 角色       | 对应语法                  | 算法意义   |
  | ---------- | ------------------------- | ---------- |
  | **容器**   | list / tuple / dict / set | 存“状态”   |
  | **推进器** | for / while               | 推进状态   |
  | **决策器** | sort / heap / bisect / if | 做最优选择 |

  ------

  ## 0.2 变量与类型：算法关心的不是“类型”，而是“语义”

  Python 是动态语言，但**算法不是动态的**。

  在算法中，我们关心的是：

  > **这个变量在“问题建模”中扮演什么角色？**

  ------

  ## 0.3 基础数据类型（状态的最小单元）

  ### 0.3.1 int / bool —— 标量状态

  算法中最常见的三类标量：

  ```python
  cnt = 0        # 方案数 / 次数
  ans = -10**18  # 最优值
  visited = False
  ```

  常见语义：

  - `int`：距离、代价、下标、容量、次数
  - `bool`：是否可行、是否访问、是否结束

  **说明**：

  - `float` 在算法中**很少用**（除非题目是物理/概率/性价比）
  - 绝大多数算法题都应避免浮点误差

  ------

  ### 0.3.2 list —— 算法中最重要的容器

  **list 是 Python 算法的基石**，你现在阶段几乎可以用 list 表达一切。

  常见用途：

  ```python
  dp = [0] * n        # DP 表
  stack = []          # 栈
  queue = []          # 队列（仅限小数据）
  path = []           # 路径记录
  ```

  **关键性质**：

  - list 是**可变对象**

  - 在回溯 / DFS 中：

    ```python
    path.append(x)
    dfs()
    path.pop()        # 必须恢复状态
    ```

  - 保存答案时必须拷贝：

    ```python
    res.append(path[:])
    ```

  ------

  ### 0.3.3 tuple —— 状态“原子化”的工具

  tuple 在算法中的核心作用只有一个：

  > **把多个量捆绑成一个“不可变状态”**

  ```python
  state = (x, y)
  state = (node, mask)
  ```

  常见使用场景：

  - BFS / Dijkstra 中的状态
  - dict / set 的 key

  ------

  ### 0.3.4 dict / set —— 状态表

  | 类型 | 算法用途       |
  | ---- | -------------- |
  | set  | 判重 / visited |
  | dict | dist / dp 映射 |

  ```python
  visited = set()
  dist = {}
  ```

  典型场景：

  - 状态空间巨大但稀疏
  - 无法开二维/三维数组

  ------

  ## 0.4 控制结构：算法的“推进方式”

  ### 0.4.1 for —— 有序、有限的状态推进

  ```python
  for i in range(n):
      dp[i] = dp[i-1] + a[i]
  ```

  算法语义：

  > **状态是“按顺序”计算的**

  典型出现位置：

  - DP
  - 前缀和
  - 扫描线

  ------

  ### 0.4.2 while —— 条件驱动的搜索

  ```python
  while queue:
      cur = queue.popleft()
  ```

  算法语义：

  > **只要还有“未处理状态”，就继续扩展**

  典型出现位置：

  - BFS
  - 双指针
  - 滑动窗口

  ------

  ### 0.4.3 if-elif-else —— 决策与剪枝

  ```python
  if cur < 0:
      restart()
  else:
      extend()
  ```

  算法意义：

  - 决定状态转移
  - 剪掉不可能成为最优解的分支

  ------

  ## 0.5 enumerate / zip —— 让算法“对人友好”

  ### 0.5.1 enumerate：下标与值绑定

  ```python
  for i, x in enumerate(nums):
      dp[i] = max(dp[i-1], x)
  ```

  优势：

  - 避免 `range(len())`
  - DP / 单调栈天然需要下标

  ------

  ### 0.5.2 zip：并行推进状态

  ```python
  for w, v in zip(weights, values):
      ...
  ```

  算法语义：

  > **这两个数组在逻辑上是“一体的”**

  常见于：

  - 背包问题
  - 图的边表示

  ------

  ## 0.6 切片（slice）：区间的直接表达

  ```python
  nums[l:r]
  nums[::-1]
  ```

  常见用途：

  - 子数组
  - 状态拷贝
  - 区间反转

  **注**：

  - 切片是 **O(k)**，不是 O(1)

  ------

  ## 0.7 lambda + sort —— 贪心算法的灵魂

  ```python
  intervals.sort(key=lambda x: x[1])
  ```

  这句话在算法中的真实含义是：

  > **“按右端点做决策”**

  ------

  ## 0.8 collections

  ### 0.8.1 deque：BFS 的标准容器

  ```python
  from collections import deque
  q = deque()
  ```

  - `append / popleft`：O(1)
  - list 的 `pop(0)`：O(n) ❌

  ------

  ### 0.8.2 defaultdict：隐式状态初始化

  ```python
  from collections import defaultdict
  d = defaultdict(int)
  ```

  常见于：

  - 计数型 DP
  - 图的邻接表

  ------

  ## 0.9 heapq —— 优先队列

  ```python
  import heapq
  ```

  算法语义：

  > **永远先处理“当前最优状态”**

  典型应用：

  - Dijkstra
  - 贪心反悔

  ------

  ### 0.9.1 懒删除思想

  ```python
  if d > dist[u]:
      continue
  ```

  允许堆中存在“过期状态”，
  **出堆时再判断是否合法**。

  ------

  ## 0.10 bisect —— 有序状态的二分工具

  ```python
  import bisect
  ```

  | 函数         | 含义       |
  | ------------ | ---------- |
  | bisect_left  | 第一个 ≥ x |
  | bisect_right | 第一个 > x |

  📌决定：

  - LIS 是否严格
  - DP 状态边界

  ------

  ## 0.11 itertools 

  ```python
  from itertools import permutations, combinations
  ```

  ⚠️ 算法警告：

  > **时间复杂度是阶乘 / 组合数级别**

  一般只适用于：

  - n ≤ 10

  ------

  ## 0.12 递归的工程问题

  ### 0.12.1 递归深度

  ```python
  import sys
  sys.setrecursionlimit(10**7)
  ```

  ------

  ### 0.12.2 记忆化 DFS

  ```python
  from functools import lru_cache
  ```

  算法意义：

  > **DFS + 记忆化 = DP 的雏形**

  ------

  ## 0.13 try-except 

  用于：

  - 多组输入
  - EOF 判断
  - 防止非法状态直接崩溃